\section{Introduction}
\subsection{Low-level system software security}
% What is low-level system software
Low-level system software plays a pivot role in the whole cyberspace that we live in -- they run everywhere because they connect the users who send commands through them and the hardware that physically performs all kinds of computational tasks. 
Conceptually, they accept and parse commands from the user, break down the tasks, convey and execute them on the real hardware.  
They are essential for this information age and the world. 
% Some example of these low-level system software
Noticeable examples of these low-level system software for today are 1). the OS kernel (e.g., the Linux kernel), and 2). the firmware. The OS kernel runs mostly on desktop and server environments to efficiently drive the common commodity hardware pieces (e.g., hard drive, CPU and RAM) and deal with the users' requests while the firmware usually runs in a more constrained hardware environment like the Micro-control Unit (MCU) and is not as user-facing as the former. 

% Why their security is important
Because of such an important role they play, they are usually placed in a high-privileged execution environment and subsequently suffer the victim of extremely calculated and powerful cyberattacks~\cite{kuruvila_hardware-assisted_2021,maggi_attacks_2020,miller_remote_2015}. Due to the fundamental nature of these critical software, patching their vulnerabilities after deployment is usually delayed, inconvenient and error-prone which leaves a window for attacks.\todo{add citation here} As a result, detecting the potentially exploitable bugs before the software being deployed in practice is crucial to mitigate these security threats.  

Meanwhile, in terms of reasoning and analyzing software, symbolic execution as well as the closely-related fuzz testing have seen huge success in various aspects of securing normal user-space programs. 
In fact, seminal works \todo{add citation here} in these fields have identified countless dangerous bugs in various user-space programs. 
Thus, it would be very tempting to apply these extensively-studied bug detecting techniques to securing these low-level system software. 
% execution units sharing address space is great, flexible, enable high performant software designs.
%Modern operating systems manage running instances of software in the granularity of processes. 
%Each process is conceptually comprised of threads for parallel job processing. While threads have 
%independent copies of the basic data structure such as process context for OS to manage their execution, they by design share the same memory address space. Sharing address space has numerous benefits. In terms of performance, it allows low-overhead communication among the running units. For example, Threads can coordinate efficiently with locking mechanisms implemented based on variable shared in the address space (e.g, spinlock~\cite{spinlock}). In terms of development flexibility, sharing the same memory space allows developers to define global data structures accessible from different components of the software.
%These benefits outweigh the risk of security back in the early 60s when the design of virtual memory was introduced. It works well when most components in a software are developed by the same party. However, as the software engineering paradigm shifts, more parties are often involved in developing a single piece of software, and therefore, the lack of security boundaries among their components becomes a realistic concern and an opportunity for attacks. This trend is driven by the following factors.

% first problem, code entities are from different origins. but they are sharing the same address space.


However, unlike the normal user-space programs which enjoy a normalized and abstract execution environment provided by the operating system, low-level system software runs in much more complex and diverse environments. 
This inevitably poses unique technical challenges when applying these well-established bug detection techniques to them. 
We identify these technical challenges as follows: 

\point{Direct and intensive interaction with the hardware} 
Unlike user-space programs which interact with the hardware through the well-defined system calls, low-level system software directly interact with the hardware through hardware-provided interfaces, namely, 1). Memory-map Input and Output (MMIO), 2). Interrupt and 3). Direct Memory Access (DMA). 
So when designing a symbolic execution or fuzz testing framework, instead of focusing on handling the generic well-defined system call interfaces, one has to consider these hardware dependencies. 
This mainly incurs three problems: 
\begin{itemize}
    \item Limited visibility and computing resource: 
            User-space program enjoys much visibility and abundance of computing resources while the low-level system software is not meant for being debugged thus has much less visibility, debugging utility as well as computing resources (e.g, RAM). 
            This is problematic since most symbolic execution and fuzz testing frameworks are built on the assumptions that it has full visibility into the programs' states and relatively large amount of computing resources. 
    \item Hardware fidelity: 
            Due to the diversity of the hardware, apart from directly accessing them, many existing works tried to emulate the hardware or to abstract them away. 
            But hardware by itself is much like the software in terms of containing complex logic, thus simple abstraction usually lead to low hardware fidelity thus false positives. 
    \item Handle hardware interfaces properly: 
            Even with the aforementioned two problems solved, there is no existing work that tried to handle these three hardware interfaces like they do for the system calls. 
            It is still yet an open problem to handle the MMIO, interrupt, and DMA properly and authentically.  
\end{itemize}


\point{Large code base} 
Low-level system software tend to have relatively large code base mainly because 1). On the hardware's front, as the hardware usually contains complex functionalities, in order to fully drive each feature from the hardware, the software on top of it needs to enumerate and handle each one of them. 2). On the user's front, it needs to accept, parse and break down the relatively semantically-rich user commands and formulate them into machine-executable tasks, this also takes a large code base to achieve.

\point{Heavily event-driven design} 
Due to the critical role that the low-level system software is playing, its performance is carefully optimized and essential to all the applications that are built on top of it. 
As a result, an event-driven design is usually employed to further improve performance. 
However, rarely does the existing works that take these events into consideration during the design of their solutions. 
They usually just use a simple heuristic-based method, which often can not be realized in practice.



In this thesis, we design three different novel solutions targeting the aforementioned challenges respectively based on the current state-of-the-art. 

%\point{Conducting code-reuse attacks} This is a more generic form of executing code in
%the context of a victim process. The attack is mostly originated from a subverted vulnerable components, attacker then redirects execution to different code sections loaded in the same process. The goal is to impersonate as the compromised process for various purposes such as privilege escalation, sandbox-escaping, etc. Since the wide adoption of mitigation techniques like Data Execution Prevention (DEP~\cite{dep}), code-reuse attacks~\cite{ropnoreturn, ret2libc, ret2libc2, ret2libc3,jitrop} have become a common attacking technique.
\subsection{Thesis Statement}

In light of the surging issue of in-process memory abuse and the lack of effective countermeasures, my research takes three steps to protect victim programs from such attacks.

First, we need new memory protection mechanisms to protect sensitive data and code against malicious code that manages to run in the same process context. One obvious solution to in-process memory abuse is to redesign the memory sharing scheme and how OSes manage execution units (i.e, threads), creating independent address space for each software components. Unfortunately, despite vast research efforts, such solutions are often not backward compatible. They require completely rewriting applications running atop, which makes such solutions impractical.

Second, we need strong and practical software attack mitigations to protect valuable yet vulnerable components from being directly exploited. As creating isolations among mutually untrusted components alone may fail to prevent such in-process memory abuse. Numerous studies~\cite{boomerang,tsgx} have shown that attackers are able to exploit code running inside trusted executing environments, bypassing all deployed mitigations~\cite{controljujutsu,jitrop,rop}. 

Lastly, since software offense and defense is an ever-going arm race. There is no existing approaches which can provide guaranteed protection against all variants of in-process memory abuse. To develop comprehensive defense, another important perspective is to stand in the shoes of an attacker. We need tools that help with finding unintended memory accessing bugs in an automated fashion. Decreasing those software bugs that lead to illegal memory access can effectively increase the bar of in-process memory abuse.

\subsection{Approaches Overview}
In this thesis, 
%I first investigate the effectiveness and feasibility of existing works that try to directly or indirectly mitigate and prevent in-process memory abuse. Then,
I present three novel techniques aiming to defend in-process memory abuse. 
%from two different aforementioned angles, namely \emph{memory access regulation} and \emph{memory access bug detection}.

%first work: shreds aids developers to create use-to-use in-process memory isolation to protect their secret data
First, I present \textsc {Shreds}~\cite{shreds}, a set of OS-backed programming primitives that addresses developers currently unmet needs for fine-grained, convenient, and efficient protection of sensitive memory content against in-process adversaries. A shred can be viewed as a flexibly defined segment of a thread execution (hence the name). Each shred is associated with a protected memory pool, which is accessible only to code running in the shred. To stay backward compatible, shreds offer in-process private memory without relying on separate page tables, nested paging, or even modified hardware. Plus, shreds provide the essential data flow and control flow protections for running sensitive code. We have built the compiler toolchain and the OS module that together enable shreds on Linux. We demonstrated the usage of shreds and evaluated their performance using 5 non-trivial open source software, including OpenSSH and Lighttpd. The results show that shreds are fairly easy to use and incur low runtime overhead (4.67\%).

%second work: norax provides xom primitive for combating information-leak based memory reuse attacks
Second, I present \textsc {Norax}~\cite{norax}, a practical system that retrofits execute-only memory (XOM) into stripped COTS binaries. Since code reuse attacks exploiting memory disclosure vulnerabilities can bypass all deployed mitigations. One promising defense against this class of attacks is to enable XOM protection on top of fine-grained ASLR. However, existing works implementing XOM, despite their efficacy, only protect programs that have been (re)built with new compiler support, leaving commercial-off-the-shelf (COTS) binaries and source-unavailable programs unprotected.  Unlike these techniques, \textsc {Norax} requires neither source code nor debugging symbols. \textsc {Norax} statically transforms existing binaries so that during runtime their code sections can be loaded into XOM memory pages with embedded data relocated and data references properly updated. \textsc {Norax} allows transformed binaries to leverage the new hardware-based XOM support--a feature widely available on AArch64 platforms (e.g., recent mobile devices) yet virtually unused due to the incompatibility of existing binaries. Furthermore, NORAX is designed to co-exist with other COTS binary hardening techniques, such as in-place randomization (IPR~\cite{ipr}). We apply NORAX to the commonly used Android system binaries running on SAMSUNG Galaxy S6 and LG Nexus 5X devices. The results show that \textsc {Norax} on average slows down the execution of transformed binaries by 1.18\% and increases their memory footprint by 2.21\%, suggesting NORAX is practical for real-world adoption.

%Finally: savior, a verifiable bug-driven hybrid testing framework, to detect memory errors that could potentially lead to 
% in-process memory abuse attacks.
Finally, I propose \textsc {Savior}, the first hybrid testing system driven by bug search and empowered with buggy condition verification. Differing from the
existing hybrid testing tools, \textsc {Savior} prioritizes the concolic execution to solve branch predicates guarding more potential 
vulnerabilities and then drives fuzz testing to reach code with more potential vulnerabilities. Going beyond that, \textsc {Savior} inspects all vulnerable 
candidates along the running program path in concolic execution. By modeling the faulty situations with SMT constraints, it solves proofs 
of valid vulnerabilities and outputs concrete test cases. Our evaluation shows that the bug-driven approach outperforms the state-of-art 
code coverage driven hybrid testing tools in vulnerability detection. In our preliminary experiments comparing \savior with state-of-the-art software testing techniques on the widely used LAVA benchmark~\cite{lava}. Within 5 hours, in addition to triggering all bugs in {\tt base64}, {\tt md5sum} and {\tt uniq}, \savior found 1904 bugs in {\tt who} and many other unlisted bugs. This is, to the best of our knowledge, by far the best results in the existing literatures.

%On average, \textsc {Savior} detects vulnerabilities XX\% faster and discovers YY\% more 
%security violations. According to the experimental result on 14 well fuzzed benchmark programs, \textsc {Savior} triggers 2196 unique security violations within 24 hours.

