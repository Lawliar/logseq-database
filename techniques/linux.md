## Make Linux Submodule
```
make modules SUBDIRS=drivers/...
```
or
```
make M=./drivers/staging/comedi/
```

## remove link generated by update-alternatives
`sudo update-alternatives --remove-all gcc`

##sudo and keep the environment variables
`sudo` seems can change the environment variables,
use `sudo -E` to keep these environment variables

## expose local port to the intenet
Local heavy task like tensorflow/syzkaller, usually use local web service to report progress, CLI tool like links/lynx functionality is very limited(a little fancy display will result in failure), thus we can either expose certain port to the public(`localchannel` is a very good tool in this regard), also, VNC can be used.

## sort htop as the process hierachy
F5

## check out port status
netstat -tulpn | grep 56741
note that, if this port is occupied by a root process, and you're normal user, the program name won't be displayed, use sudo to show the program name.

## check out the directory size
du -h -d 1

## ssh set-up
after key gen, you have `id_rsa` and `id_rsa.pub`, former, your private key, is passphrase protected, the latter, you pub key, is your public identity.
### remote setting
copy `id_rsa.pub` to your remote server which you use your pub key as a login authentication method, and append it into `~/.ssh/authorized_keys`, 
then the remote server can recognize you as an authenticated party.
### local setting
place your two key files into ~/.ssh/
add 
`eval `ssh-agent`
ssh-add
`
to your .bashrc, then ssh-agent will remember the passphrase you use (to protect the private key), so, you don't have to input the passphrase everytime you use your private key.

now, you should be able to just ssh remote\_user@server to login to your server.

## bash command line
ctrl + a: move cursor to the beginning of the cmd line
ctrl + u: clear current line
ctrl + e: move cursor to the end of this line

## ports
sudo lsof -i -P -n | grep LISTEN
sudo netstat -tulpn | grep LISTEN
sudo lsof -i:22 ## see a specific port such as 22 ##
sudo nmap -sTU -O IP-address-Here

## pipe
https://askubuntu.com/questions/420981/how-do-i-save-terminal-output-to-a-file


## shared memory

1. key_id = ftok(...)
2. block_id = shmget(key_id...)
3. ptr = shmat(block_id), shmdt(ptr)

without 1, you can also specify key_id to IPC_PRIVATE

### Different between shared memory key(key_id) and shared memory ID(block ID)
https://stackoverflow.com/questions/19518607/shared-memory-whats-the-difference-between-the-key-and-the-id

## pmap <PID>
meassure memory


## if some software installation page force you to read some licence, and you keep pressing enter, and miss the "do you accept" and default to N, thus abort
Just press Ctrl+C or S to scroll to the last


## /etc/fstab
https://wiki.debian.org/fstab
sth like this if you wanto to mount a folder shared in windows to linux
`
//10.110.150.217/Users/lcm/Documents/GitHub /home/lcm/win-github cifs username=lcm,noauto,sync,rw,users 0 0
`

## check if a mountpoint is mounted
https://serverfault.com/questions/50585/whats-the-best-way-to-check-if-a-volume-is-mounted-in-a-bash-script

## failed to create symbolic link: operation not supported on socket
most likely it's because you're making a shared library in a shared folder, making shared library is not supported, somehow? Just move to a local folder, because creating a sym link to a shared file(not physically located in the file system) does not make too much sense.
## invalid value of canonical build
https://github.com/openucx/ucx/issues/3871


## merge output of different commands together:
https://unix.stackexchange.com/questions/64736/combine-the-output-of-two-commands-in-bash
`(command1 & command 2)`

## user log out
sudo pkill -KILL -u <username>

## shell does not support up arrow:
https://askubuntu.com/questions/325807/arrow-keys-home-end-tab-complete-keys-not-working-in-shell

## list file recursively
`tree`

## watch
watch "ps au"


## install 32-bit library on 64 bit OS
### When you try to build a 32-bit lib/exe on a 64-bit OS, if you have to install all kinds of 32-bit dependent libraries/packages(binutil:i386), and it starts messing with the 64-bit libraries, you should seriously consider if you should just use a 32-bit docker image
https://askubuntu.com/questions/1304803/ubuntu-20-04-install-both-32-bit-and-64-bit-libraries
check out the foreign arch and add that e.g. apt install z3:i386
### if the docker doesn't have 32bit image(say for example, not ubuntu-20.04 still don't have 386 support)chroot is the best option
follow these two links
https://help.ubuntu.com/community/BasicChroot
https://www.r-bloggers.com/2012/03/build-32-bit-r-on-64-bit-ubuntu-by-utilizing-chroot/
`sudo debootstrap --variant=buildd --arch i386 Focal /home/lcm/github/symcc/chroot http://mirror.enzu.com/ubuntu/`


## check where the apt package is installed
dpkg -L libz3-dev:i386

## if a shared library is missing: maybe you need to clean the cache
https://stackoverflow.com/questions/21758828/purging-and-rebuilding-ldconfig-cache
`
rm /etc/ld.so.cache
ldconfig
`

## `locate` from `apt install mlocate`
usage: `locate libc.so.6` to see the locations of these libraries
## lddtree
`sudo apt install pax-utils`



## linux from scratch
https://www.linuxfromscratch.org/lfs/downloads/stable/LFS-BOOK-11.3.pdf
